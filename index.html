<!DOCTYPE html><html><header><meta charset="utf-8" /><meta name="author" content="Mario Pastorelli" /><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /><link rel="stylesheet" href="css/reveal.min.css" /><link rel="stylesheet" href="css/theme/night_custom.css" id="theme" /><link rel="stylesheet" href="css/custom.css" /><link rel="stylesheet" href="lib/css/zenburn.css" /><script>document.write( '<link rel="stylesheet"href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script><title>Hawk</title></header><body><div class="reveal"><div class="slides"><section><h1>Haskell-awk</h1><h3>Haskell text processor for the command-line</h3><p><address><a href="mailto:pastorelli.mario@gmail.com">Mario Pastorelli</a></address></p></section><section><h2>Introduction</h2></section><section><h2>awk</h2><ul><li>a generic <strong>text processor</strong> where<br /><br /><blockquote>&ldquo;A file is treated as a sequence of <strong>records</strong>, and by default <strong>each line</strong> is a <strong>record.</strong>&rdquo; - Alfred V. Aho</blockquote></li><br /><li class="fragment">developed in <strong>1977</strong> by Alfred <strong>A</strong>ho, Peter <strong>W</strong>einberger, and Brian <strong>K</strong>ernighan @ <strong>Bell Labs</strong></li><br /><li class="fragment">uses <strong>AWK</strong> as programming language<pre><code class="haskell">awk 'BEGIN { print "Hello World!" }'</code></pre><ul><li><strong>procedural</strong></li><li><strong>interpreted</strong></li><li>a program is a series of <strong>pattern action</strong> pairs</li></ul></li></ul></section><section><h2>Why another awk?</h2><ul><blockquote>&ldquo;Whenever faced with a problem, some people say `Lets use AWK.&#39; Now, they have <strong>two problems.</strong>&rdquo; - D. Tilbrook</blockquote><br /><li class="fragment"><strong>avoid</strong> the AWK programming language<ul><li>use a <strong>generic</strong> language, not a DSL</li><pre><code class="haskell">BEGIN{split("a b c c a",a);for(i in a)b[a[i]]=1;r="";for(i in b)r=r" "i;print r}</code></pre><pre><code class="haskell">nub $ words "a b c c a"</code></pre></ul></li><br /><li class="fragment">procedural (imperative) vs functional programming for<strong> stream processing</strong></li></ul></section><section><h2>Haskell-awk (Hawk)</h2><ul><li>a generic <strong>text processor</strong> where<br /><br /><blockquote>&ldquo;A stream is treated as a sequence of <strong>records</strong>, and by default <strong>each line</strong> is a <strong>record.</strong>&rdquo;</blockquote><br />the same philosophy of awk!</li><br /><li class="fragment">developed in <strong>2013</strong> by me and Samuel GÃ©lineau, the name is a tribute to awk</li><br /><li class="fragment">uses <strong>Haskell</strong> as programming language<pre><code class="haskell">hawk '"Hello World!"'</code></pre><ul><li><strong>functional</strong></li><li><strong>(incrementally) compiled</strong></li><li>a program is a <strong>Haskell expression</strong></li></ul></li></ul></section><section><h2>Why Haskell</h2><ul><li><strong>expressive</strong>, <strong>clean</strong> and <strong>concise</strong><pre><code class="haskell">> filter odd [1,2,3,4]
[1,3]</code></pre></li><li class="fragment">functions as <strong>composable building blocks</strong><pre><code class="haskell">> let wordCount = sum . map (length . words) . lines

> :type wordCount
wordCount :: String -> Int

> wordCount "1 2 3\n4 5 6\n7 8 9"
9
</code></pre></li><li class="fragment"><strong>partial application</strong><pre><code class="haskell">> :type map
map :: (a -> b) -> [a] -> [b]

> :type not
not :: Bool -> Bool

> :type map not
map not :: [Bool] -> [Bool]

> map not [True,False]
[False,True]
</code></pre></li><li class="fragment"><strong>point-free style</strong>, <strong>laziness</strong> ...</li></ul></section><section><h2>Hawk</h2></section><section><h2>Modes</h2><ul><li><strong>evaluate</strong> an expression<pre><code class="bash">$ hawk '1'
1
</code></pre><pre><code class="bash">$ hawk '[1,2]'
1
2
</code></pre><pre><code class="bash">$ hawk '[[1,2],[3,4]]''
1 2
3 4
</code></pre></li><br /><li class="fragment"><strong>apply</strong> an expression to the input<pre><code class="bash">$ echo '1\n2\n3' | hawk -a 'L.reverse'
3
2
1
</code></pre></li><br /><li class="fragment"><strong>map</strong> an expression to each record of the input<pre><code class="bash">$ echo '1 2\n3 4' | hawk -m 'L.reverse'
2 1
4 3
</code></pre></li></ul></section><section><h2>IO format</h2><ul><li>The <strong>input</strong> is, by default, a list of list of strings where lines are separated by \n and words by spaces<pre><code class="bash">$ echo '1 2\n3 4' | hawk -a 'show'
[["1","2"],["3","4"]]
</code></pre></li><li class="fragment">Options <strong>-d</strong>/<strong>-D</strong> are provided to change delimiters or set them to empty<pre><code class="bash">$ echo '1,2;3,4' | hawk -a -d',' -D';' 'show'
[["1","2"],["3","4"]]
</code></pre><pre><code class="bash">$ echo '1 2\n3 4' | hawk -a -d'' 'show'
["1 2","3 4"]
</code></pre><pre><code class="bash">$ echo '1 2\n3 4' | hawk -a -d'' -D'' 'show'
"1 2\n3 4\n"
</code></pre></li><br /><li class="fragment">The <strong>output</strong> can be any type that instantiate the typeclass <strong>Rows</strong><pre><code class="haskell">class (Show a) => Rows a where
	repr :: ByteString -> a -> [ByteString]
</code></pre></li></ul></section><section><h2>Examples</h2><ul><li>get <strong>all users</strong> of a UNIX system<pre><code class="bash">$ cat /etc/passwd | hawk -d: -m 'L.head'
root
daemon
...
</code></pre></li><li class="fragment">select <strong>username</strong> and <strong>userid</strong><pre><code class="bash">$ cat /etc/passwd | hawk -d: -o'\t' -m '\l -> (l !! 0,l !! 2)'
root	0
daemon	1
...
</code></pre></li><li class="fragment"><strong>sort by username</strong> (instead of pid)<pre><code class="bash">$ cat /etc/passwd | hawk -d: -a 'L.sortBy (compare `on` L.head)'
bin:x:2:2:bin:/bin:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
...
</code></pre></li><li class="fragment">get the <strong>number of users</strong> using each shell<pre><code class="bash">> cat /etc/passwd | hawk -ad: 'L.map (L.head &&& L.length) . L.group . L.sort . L.map L.last'
/bin/bash:1
...
</code></pre></li></ul></section><section><h2>Context</h2><ul><li>Hawk can be <strong>customized</strong> using files inside the <strong>context directory</strong> (by default ~/.hawk)</li><br /><li class="fragment">The most important file is <strong>prelude.hs</strong> that contains the &quot;runtime context&quot;<pre><code class="haskell">$ cat ~/.hawk/prelude.hs
{-# LANGUAGE ExtendedDefaultRules, OverloadedStrings #-}
import Prelude
import qualified Data.ByteString.Lazy.Char8 as B
import qualified Data.List as L
</code></pre></li><br /><li class="fragment">for instance, we can <strong> add a function</strong> for taking elements in an interval<pre><code class="haskell">$ echo 'takeBetween s e = L.take (e - s) . L.drop s' >> ~/.hawk/prelude.hs
$ seq 0 100 | hawk -a 'takeBetween 2 4'
2
3
</code></pre></li></ul></section><section><h2>Implementation</h2></section><section><h2>Hawk must be fast</h2><ul><li><strong>cache</strong> the context<ul><li>use the <strong>timestamp</strong> to check if the context is changed since last run</li><li>compile it with <strong>ghc</strong></li></ul></li><li class="fragment">use <strong>locks</strong> to compile only once when multiple Hawk instances instances are running<pre><code class="bash">hawk '[1..]' | hawk -a 'L.take 3'</code></pre></li><li class="fragment">use <strong>ByteString</strong> instead of String</li><li class="fragment">...</li></ul></section><section><h2>Parse and interpret Haskell</h2><ul><li>Hawk combines two Haskell libraries<br /><br /><ul><li><strong>haskell-src-exts</strong> to deal with haskell source code<pre><code class="haskell">> import Language.Haskell.Exts.Parser
> getTopPragmas "{-# LANGUAGE NoImplicitPrelude,OverloadedStrings #-}\n"
ParseOk [LanguagePragma (SrcLoc
 {srcFilename = "unknown.hs", srcLine = 1, srcColumn = 1}) 
[Ident "NoImplicitPrelude",Ident "OverloadedStrings"]]
</code></pre></li><br /><li class="fragment"><strong>hint</strong> to interpret the user expression<pre><code class="haskell">> import Language.Haskell.Interpreter
> runInterpreter $ setImports ["Data.Int"] >> interpret "1" (as :: Int)
Right 1
> runInterpreter $ setImports ["Data.Int"] >> interpret "foo" (as :: Int)
Left (WontCompile [GhcError {errMsg = "Not in scope: `foo'"}])
</code></pre></li></ul></li></ul></section><section><h2>Thank you!</h2><br /><a href="https://github.com/gelisam/hawk">https://github.com/gelisam/hawk</a></section></div></div><script src="lib/js/head.min.js"></script><script src="js/reveal.min.js"></script><script>Reveal.initialize({controls: true,progress: true,history: true,center: true,margin: 0.1,theme: Reveal.getQueryHash().theme,transition: Reveal.getQueryHash().transition || 'linear',dependencies: [  { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },  { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },  { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },  { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },  { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },  { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]});</script></body></html>